diff -aur afl-2.39b.orig/afl-fuzz.c afl-2.39b/afl-fuzz.c
--- afl-2.39b.orig/afl-fuzz.c	2016-11-27 10:10:23.000000000 +0800
+++ afl-2.39b/afl-fuzz.c	2017-04-19 23:38:06.109999992 +0800
@@ -45,6 +45,7 @@
 #include <termios.h>
 #include <dlfcn.h>
 #include <sched.h>
+#include <netdb.h>
 
 #include <sys/wait.h>
 #include <sys/time.h>
@@ -55,6 +56,9 @@
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #include <sys/file.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <sys/sendfile.h>
 
 #if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
 #  include <sys/sysctl.h>
@@ -89,7 +93,8 @@
           *in_bitmap,                 /* Input bitmap                     */
           *doc_path,                  /* Path to documentation dir        */
           *target_path,               /* Path to target binary            */
-          *orig_cmdline;              /* Original command line            */
+          *orig_cmdline,              /* Original command line            */
+          *qemu_lib_path;             /* Path to the lib of QEMU guest    */
 
 EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */
 EXP_ST u64 mem_limit = MEM_LIMIT;     /* Memory cap for child (MB)        */
@@ -217,6 +222,29 @@
 
 static FILE* plot_file;               /* Gnuplot output file              */
 
+/* Globals for network support */
+
+static struct addrinfo *N_results = NULL, /* for results from getaddrinfo() */
+                       *N_rp = NULL;      /* to iterate through N_results[] */
+
+static struct sockaddr_storage N_myaddr; /* to hold send port info        */
+static struct sockaddr_storage N_server_addr; /* and server (send side)   */
+static socklen_t N_myaddrlen = sizeof (struct sockaddr_storage);
+                                      /* and length of both               */
+
+static u32 N_option_specified = 0;    /* 1 if a -N option is present      */
+static u8* N_option_string = 0;       /* points to copy of -N option str  */
+static u32 N_slen = 0;                /* length of the -N option string   */
+static u32 N_valid = 0;               /* 1 if valid URL option to -N      */
+static u32 N_fuzz_client = 0;         /* 1 if target is a network client  */
+static u32 N_myaddr_valid = 0;        /* use established conn or addr     */
+static s32 N_fd;                      /* for network file descriptor      */
+
+static u32 N_timeout_given = 0;       /* use delay before network I/O     */
+static u32 N_exec_tmout = 0;          /* network I/O delay in msec        */
+static struct timespec N_it;          /* structure for nanosleep() call   */
+
+
 struct queue_entry {
 
   u8* fname;                          /* File name for the test case      */
@@ -1958,6 +1986,511 @@
 
 }
 
+/* Code to fuzz targets across localhost/127.0.0.1/::1 network interface
+ * 
+ * The network fuzzing code operates in each of two modes depending upon
+ * the type of target:
+ * 
+ * (1) as a "listener" or "server" to fuzz targets that send a request to 
+ *     another process and expect a response.  These targets are called
+ *     "clients". The relevant functions are network_setup_listener(),
+ *     which creates a socket and binds that socket to a (local) port
+ *     specified on the command line, and network_listen(), which expects
+ *     to receive a packet (UDP) or stream of data (TCP) from the target
+ *     and sends a fuzzed response.  This mode is selected using the -b
+ *     command line option, together with the -N command line option.
+ * 
+ * (2) as a "client" to fuzz targets that expect to receive a request from
+ *     another process.  These targets are called "servers" or "daemons".
+ *     The relevant function is network_send(), which sends a fuzzed
+ *     packet (UDP) or stream of data (TCP) to the target.  This mode is
+ *     selected using the -N command line option without the -b command
+ *     line option.
+ * 
+ *  */
+
+void network_setup_listener(void) {
+  /* exit if getaddrinfo() did not return address information structures
+   * that match the specification on the command line */
+  if (N_results != NULL) {
+    /* two cases: SOCK_STREAM (for TCP) and SOCK_DGRAM (for UDP) */
+    if (N_results->ai_socktype == SOCK_STREAM) {
+      /* TCP (stream) and connections are used.
+       * 
+       * A connection must be established from the target each 
+       * time network_listen() is called, and closed after the data are 
+       * transfered.  network_setup_listener() creates a stream socket
+       * (with the file descriptor N_fd) and listens for connection requests.  
+       * This must be done before a target that expects to connect is executed.
+       * N_myaddr_valid tells the codes that the listening socket has been
+       * setup (and keeps this code from running twice as a safety net). 
+       * UDP is connectionless and quite different. See below.
+       * 
+       * Local variables: */
+      int optval = 1;
+      if (N_myaddr_valid == 0) { /* don't do this twice! */
+        /* Find the first address that works and use it. */
+        for (N_rp = N_results; N_rp != NULL; N_rp = N_rp->ai_next) {
+          /* create the socket, skipping to the next addrinfo object on failure */
+          N_fd = socket(N_rp->ai_family, N_rp->ai_socktype, N_rp->ai_protocol);
+          if (N_fd == -1) {
+            close(N_fd);
+            continue;
+          }
+          /* set the socket option to reuse both the address and port */
+          if (setsockopt(N_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &optval,
+                  sizeof (optval)) == -1) {
+            close(N_fd);
+            PFATAL("failed to set socket option (TCP case)");
+          }
+          /* if bind() succeeds, we have found an address that works */
+          if (bind(N_fd, N_rp->ai_addr, N_rp->ai_addrlen) != -1) {
+            break;
+          }
+          close(N_fd);
+        }
+        /* if none is found, the user needs to examine the argument list */
+        if (N_rp == NULL) {
+          FATAL("failed to bind socket");
+        }
+        /* listen for connection attempts.  this can fail if another process
+         * is listening to the same port and address */
+        if (listen(N_fd, 8) == -1) PFATAL("listen() failed");
+        /* indicate that the socket has been created & bound to a port, and
+         * that the process is listening for connection attempts. */
+        N_myaddr_valid = 1;
+      }
+    } else if (N_results->ai_socktype == SOCK_DGRAM) {
+      /* UDP datagrams are used.
+       * 
+       * Create a socket to be used to both receive and send packets, referenced
+       * by the file descriptor N_fd.
+       * 
+       * N_fd is kept open for the duration of the afl run (closed on exit)
+       * and reused.  N_myaddr_valid signals the code that the UDP socket 
+       * has been set up and bound to the sending side of the address & port.
+       * 
+       * First time: find the appropriate sockaddr structure to be used and
+       * set up the sending side's socket. After the first time's successful
+       * execution, N_rp points to the address information corresonding to
+       * the sending side's socket information.
+       *
+       * Local variables:
+       */
+    int optval = 1;
+    if (N_myaddr_valid == 0) {
+        for (N_rp = N_results; N_rp != NULL; N_rp = N_rp->ai_next) {
+          /* create the socket, skipping to the next addrinfo object on failure */
+          N_fd = socket(N_rp->ai_family, N_rp->ai_socktype, N_rp->ai_protocol);
+          if (N_fd == -1) {
+            fprintf(stderr, "socket() call failed\n");
+            close(N_fd);
+            continue;
+          }
+          /* set the socket option to reuse both the address and port */
+          if (setsockopt(N_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &optval,
+                  sizeof (optval)) == -1) {
+            close(N_fd);
+            PFATAL("failed to set socket option (TCP case)");
+          }
+          /* if bind() succeeds, we have found an address that works */
+          if (bind(N_fd, N_rp->ai_addr, N_rp->ai_addrlen) != -1) {
+            break;
+          }
+          close(N_fd);
+        }
+        /* if none is found, the user needs to examine the argument list */
+        if (N_rp == NULL) {
+          FATAL("failed to bind socket");
+        }
+        /* indicate that the socket has been created & bound to a port, and
+         * that the process is listening for connection attempts. */
+        N_myaddr_valid = 1;
+      }
+    }
+  } else {
+    /* getaddrinfo() failed to return results matching the spec on the
+     * command line.  */
+    FATAL("no matching results from getaddrinfo()");
+  }
+}
+
+int network_listen(void) {
+  /* This function receives data from the target process, and then sends
+   * fuzzed data back to it.  There are two cases:
+   *
+   * (1) TCP (streams): a connection attempt from the target process is
+   *     solicited.  When the connection has been established, all available
+   *     data are read using non-blocking I/O, and then fuzzed data are
+   *     written.
+   *
+   * (2) UDP (datagrams/packets): all available packets are read using
+   *     non-blocking I/O, and then fuzzed data are written.
+   *
+   * In both cases, all data read are discarded.  Note that for UDP reads
+   * any data in excess of the size of the read buffer are discarded by the
+   * network stack.
+   * 
+   * Note that non-blocking reads are attempted, and if they fail then the
+   * calling process is expected to wait for a programmed interval of time
+   * (specified by the -D command line argument) and retry the call to
+   * network_listen(), for a programmed number of times (not user-selectable).
+   * 
+   * Note that unlike the case where this code plays the role of a client to
+   * the target process (using network_send()), we typically have no control
+   * over the target's reuse (or not) of ephemeral port numbers.  Therefore,
+   * we are at the mercy of the network stack's ability to scavenge available
+   * port numbers.  A recent Linux kernel appears to do this quite well;
+   * other operating systems may not.
+   *
+   * Local variables:
+   */
+  u32 MAXRECVBUFSIZE = 512;
+  u8 recvbuf[MAXRECVBUFSIZE];
+  s32 currreadlen, client_fd, fd, o;
+  /* network_setup_listener() must be called first, and must succeed */
+  if (!N_myaddr_valid)
+    FATAL("error: network_listen() called before network_setup_listener()");
+  
+  /* Two cases: SOCK_STREAM (for TCP) and SOCK_DGRAM (for UDP) */
+  if (N_rp->ai_socktype == SOCK_STREAM) {
+    /* TCP (stream) and connections are used. */
+    /* accept a connection if the client is ready, but don't block */
+    client_fd = accept4(N_fd, (struct sockaddr *) &N_myaddr,
+            &N_myaddrlen, SOCK_CLOEXEC | SOCK_NONBLOCK);
+    if (client_fd == -1) {
+      if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
+        return -1; /* return to calling program, which will delay before retrying */
+      } else { /* a serous error occurred */
+        PFATAL("accept4() returned error other than EAGAIN or EWOULDBLOCK");
+      }
+    }
+    /* read whatever the client sends and throw it away, resetting
+     * non-blocking mode first (because some UNIXs propagate it to
+     * the returned client_fd) */
+    o = fcntl(client_fd, F_GETFL);
+    if (o >= 0) {
+      o = o & (~O_NONBLOCK);
+      if (fcntl(client_fd, F_SETFL, o) < 0) {
+        PFATAL("failed to reset non-blocking flag on client file descriptor (TCP)");
+      }
+    }
+    while ((currreadlen = recv(client_fd,recvbuf,MAXRECVBUFSIZE,MSG_DONTWAIT)) > 0);
+    if ((currreadlen <= 0) && (errno != EAGAIN) && (errno != EWOULDBLOCK)) {
+      PFATAL("read error");
+    }
+    /* duplicate the file descriptor used for the fuzzed data, and use the new
+     * file descriptor to read that data and send it to the target process */
+    fd = dup(out_fd);
+    struct stat statbuf;
+    /* stat the file descriptor to obtain the size of the data to be sent */
+    if (fstat(fd, &statbuf) == -1) {
+      PFATAL("failed to obtain stat for output file to target");
+    }
+    /* seek to the beginning of the file */
+    lseek(fd, 0, SEEK_SET);
+    /* use sendfile() to transfer the data if possible because it is efficient */
+    if (sendfile(client_fd, fd, NULL, statbuf.st_size) == -1) {
+      /* if sendfile() didn't work, use read() and write() via a buffer */
+      lseek(fd, 0, SEEK_SET); /* reset to the beginning of the file */
+      u8 tempbuf[512];
+      u32 kread;
+      while ((kread = read(fd, tempbuf, 512)) > 0) {
+        if (write(client_fd, tempbuf, kread) != kread) {
+          PFATAL("file copy to network socket failed (TCP)");
+        }
+      }
+    }
+    /* leave a clean campsite (as we found it) */
+    lseek(fd, 0, SEEK_SET);
+    close(fd);
+    /* and close the file descriptor of the socket for the target */
+    close(client_fd);
+    
+  } else if (N_rp->ai_socktype == SOCK_DGRAM) {
+    /* UDP datagrams are used.
+     *
+     * N_fd is kept open for the duration of the afl run (closed on exit)
+     * and reused.  N_myaddr_valid signals this code that the UDP socket
+     * has been set up and bound to the sending side of the address & port.
+     * N_rp points to the address information used for the socket.
+     *
+     * Local variables:
+     */
+    struct stat statbuf;
+    struct sockaddr_storage clientaddr;
+    u32 clientaddrlen = sizeof (struct sockaddr_storage);
+    /* read all available packets from the socket using non-blocking I/O */
+    {
+      int received_one = 0;
+      while ((currreadlen = recvfrom(N_fd, recvbuf, MAXRECVBUFSIZE, MSG_DONTWAIT,
+              (struct sockaddr *) &clientaddr, &clientaddrlen)) > 0) {
+        received_one = 1;
+      }
+      /* at least one is necessary; otherwise, return & calling program may
+       * wait and then try again */
+      if (!received_one) {
+        if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
+          return -1;
+        } else {
+          /* any other error signals imply a serious problem exists */
+          PFATAL("read error");
+        }
+      }
+   }
+    /* duplicate the file descriptor used for the fuzzed data, and use the new
+     * file descriptor to read that data and send it to the target process */
+    fd = dup(out_fd);
+    /* stat the file descriptor to obtain the size of the data to be sent */
+    if (fstat(fd, &statbuf) == -1) PFATAL("fstat()failed");
+    /* seek to the beginning of the file and create a temporary buffer to
+     * hold all of the data in the file */
+    lseek(fd, 0, SEEK_SET);
+    u8 tempbuf[statbuf.st_size];
+    /* read the entire file into the buffer */
+    if (read(fd, tempbuf, statbuf.st_size) != statbuf.st_size)
+      PFATAL("read of outfile's content failed to return expected # of bytes");
+    /* and send the buffer's content to the target process.  Note that this
+     * code assumes that the entire buffer can be sent in a single packet.  If
+     * it can not (giant packet), the user may be doing something wrong.  */
+    if (sendto(N_fd, tempbuf, statbuf.st_size, 0,
+            (struct sockaddr *)&clientaddr,
+            clientaddrlen) < 0) {
+      PFATAL("partial or failed UDP write");
+    }
+    /* leave a clean campsite (as we found it) */
+    lseek(fd, 0, SEEK_SET);
+    close(fd);
+  }
+  return 0;
+}
+
+int network_send(void) {
+  /* This function sends fuzzed data to a target process.  There are two cases:
+   *
+   * (1) TCP (streams): a connection to the target process is attempted.
+   *     When the connection has been established, the fuzzed data are
+   *     written.
+   *
+   * (2) UDP (datagrams/packets): The fuzzed data are written.
+   *
+   * N_results should never be a NULL pointer because the return code
+   * from getaddrinfo() is checked. */
+  if (N_results != NULL) {
+    
+    /* Two cases: SOCK_STREAM (for TCP) and SOCK_DGRAM (for UDP) */
+    if (N_results->ai_socktype == SOCK_STREAM) {
+      /* TCP (stream) and connections are used.
+       * 
+       * NOTE: A TCP connection must be established each time this code
+       * is called, and closed after the data are transfered.  However, the
+       * same port number should be used for the sending (this) side of the
+       * TCP transaction every time.  Otherwise, ephemeral port
+       * numbers might be exhausted because of TCP's TIME_WAIT timeout
+       * interval.  N_myaddr_valid tells this code that the sending side's
+       * address information has been stored in N_myaddr and is to be reused. 
+       * UDP is connectionless and is therefore different. See below.
+       * 
+       * Note that the other mode of operation, where this code acts as a
+       * server to a target, does not have control over the target's reuse
+       * of ephemeral port numbers.  See the comments in network_listen()
+       * for a discussion.
+       * 
+       * Note that "soft" failures cause a return with an error code of -1. The
+       * calling process is expected to wait for a programmed interval of time
+       * (specified by the -D command line argument) and retry the call to
+       * network_send(), for a programmed number of times (not user-selectable)
+       * when this occurs.
+       * 
+       * Local variables: */
+      int optval = 1;
+
+      if (N_myaddr_valid == 0) {
+        /* First time: Find the correct address and use it, saving the info
+         * in M_myaddr for subsequent calls. */
+        for (N_rp = N_results; N_rp != NULL; N_rp = N_rp->ai_next) {
+          /* create a socket to connect to the target process */
+          N_fd = socket(N_rp->ai_family, N_rp->ai_socktype, N_rp->ai_protocol);
+          if (N_fd == -1) {
+            continue;
+          }
+          /* set the socket options to reuse both the address and port */
+          if (setsockopt(N_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &optval,
+                  sizeof (optval)) == -1) {
+            PFATAL("failed to set socket option (TCP case)");
+          }
+          /* attempt to connect to the target process, breaking out of the
+           * loop upon success */
+          if (connect(N_fd, N_rp->ai_addr, N_rp->ai_addrlen) != -1) {
+            break;
+          }
+          /* connect() failed, so close the file descriptor and try the
+           * next address information data structure */
+          close(N_fd);
+        }
+        if (N_rp == NULL) {
+          return -1; /* failed to connect; target process probably not ready */
+        }
+        /* obtain the send side socket information for re-use */
+        if (getsockname(N_fd, (struct sockaddr *) (&N_myaddr), &N_myaddrlen) == -1) {
+          PFATAL("unable to obtain local socket address information (TCP case)");
+        }
+        N_myaddr_valid = 1;
+      } else {
+        /* This is not the first time; reuse send side info in N_myaddr. */
+        N_fd = socket(N_rp->ai_family, N_rp->ai_socktype, N_rp->ai_protocol);
+        if (N_fd == -1) {
+          PFATAL("Subsequent attempt to create socket failed (TCP case)");
+        }
+        if (setsockopt(N_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &optval,
+                sizeof (optval)) == -1) {
+          PFATAL("Subsequent attempt to set socket option failed (TCP case)");
+        }
+        if (bind(N_fd, (struct sockaddr *) (&N_myaddr), N_myaddrlen) == -1) {
+          PFATAL("Attempt to bind socket to source address & port failed (TCP case)");
+        }
+        if (connect(N_fd, N_rp->ai_addr, N_rp->ai_addrlen) != -1) {
+        } else {
+          close(N_fd);
+          return -1; /* error returned from connect; target process not ready */
+        }
+      }
+
+      {
+        /* duplicate the file descriptor used for the fuzzed data, and use
+         * the new file descriptor to read that data and send it to the
+         * target process */
+        s32 fd = dup(out_fd);
+        /* stat the file descriptor to obtain the size of the data to be sent */
+        struct stat statbuf;
+        if (fstat(fd, &statbuf) == -1) PFATAL("fstat()failed");
+        /* seek to the beginning of the file */
+        lseek(fd, 0, SEEK_SET);
+        /* use sendfile() to transfer the data if possible because it is efficient */
+        if (sendfile(N_fd, fd, NULL, statbuf.st_size) == -1) {
+          /* if sendfile() didn't work, use read() and write() via a buffer */
+          lseek(fd, 0, SEEK_SET); /* reset to the beginning of the file */
+          /* create a temporary buffer to hold all of the data in the file */
+          u8 tempbuf[512];
+          u32 kread;
+          while ((kread = read(fd, tempbuf, 512)) > 0) {
+            if (write(N_fd, tempbuf, kread) != kread) {
+              PFATAL("file copy to network socket failed (TCP)");
+            }
+          }
+        }
+        /* leave a clean campsite (as we found it) */
+        lseek(fd, 0, SEEK_SET);
+        close(fd);
+      }
+      /* and close the connection to the target process, signaling EOF */
+      close(N_fd);
+      
+    } else if (N_results->ai_socktype == SOCK_DGRAM) {
+      /* UDP datagrams are used.
+       * 
+       * N_fd is kept open for the duration of the afl run (closed on exit)
+       * and reused.  N_myaddr_valid signals this code that the UDP socket
+       * has been set up and bound to the sending side of the address & port.
+       * N_rp points to the recipient side's address information after the
+       * first call. */
+
+      if (N_myaddr_valid == 0) {
+        /* First time: find the appropriate sockaddr structure to be used and
+         * set up the sending side's socket. After the first time's successful
+         * execution, N_myaddr holds the sending side's socket information,
+         * N_rp points to the socket address structure that was used to
+         * create the socket, and N_fd is a valid file descriptor for the
+         * socket. */
+        for (N_rp = N_results; N_rp != NULL; N_rp = N_rp->ai_next) {
+          if (!((N_rp->ai_family == AF_INET) || (N_rp->ai_family == AF_INET6))) {
+            continue;
+          }
+          /* create appropriate struct sockaddr according to ai_family */
+          if (N_rp->ai_family == AF_INET6) {
+            memset(&N_server_addr, 0, sizeof (struct sockaddr_in6));
+            N_server_addr.ss_family = AF_INET6;
+            ((struct sockaddr_in6 *) &N_server_addr)->sin6_family = AF_INET6;
+            ((struct sockaddr_in6 *) &N_server_addr)->sin6_addr = in6addr_any;
+            ((struct sockaddr_in6 *) &N_server_addr)->sin6_port = 0;
+          } else if (N_rp->ai_family == AF_INET) {
+            memset(&N_server_addr, 0, sizeof (struct sockaddr_in));
+            N_server_addr.ss_family = AF_INET;
+            ((struct sockaddr_in *) &N_server_addr)->sin_family = AF_INET;
+            ((struct sockaddr_in *) &N_server_addr)->sin_addr.s_addr = INADDR_ANY;
+            ((struct sockaddr_in *) &N_server_addr)->sin_port = 0;
+          } else {
+            FATAL("invalid ai_family (UDP case)");
+          }
+          /* create socket */
+          N_fd = socket(N_rp->ai_family, N_rp->ai_socktype, N_rp->ai_protocol);
+          if (N_fd == -1) {
+            continue;
+          }
+          /* bind to the address using an ephemeral port number */
+          if (bind(N_fd, (struct sockaddr *) &N_server_addr, sizeof (struct sockaddr_storage)) < 0) {
+            PFATAL("bind failed (UDP case)");
+          } else {
+            /* obtain the local port number that was assigned (for debugging) */
+            N_myaddrlen = sizeof (struct sockaddr_storage);
+            if (getsockname(N_fd, (struct sockaddr *) &N_myaddr, &N_myaddrlen) < 0) {
+              PFATAL("get socket name failed (UDP case)");
+            } else {
+              break;
+            }
+          } 
+          close(N_fd);
+        }
+        N_myaddr_valid = 1;
+      }
+      if (N_rp == NULL) {
+        return -1; /* failed to connect on any address (UDP case) */
+      }
+      {
+        /* duplicate the file descriptor used for the fuzzed data, and use
+         * the new file descriptor to read that data and send it to the
+         * target process */
+        s32 fd = dup(out_fd);
+        /* stat the file descriptor to obtain the size of the data to be sent */
+        struct stat statbuf;
+        if (fstat(fd, &statbuf) == -1) PFATAL("fstat()failed");
+        /* seek to the beginning of the file */
+        lseek(fd, 0, SEEK_SET);
+        /* create a temporary buffer to hold all of the data in the file */
+        u8 tempbuf[statbuf.st_size];
+        /* read the entire file into the buffer */
+        if (read(fd, tempbuf, statbuf.st_size) != statbuf.st_size) {
+          PFATAL("read of outfile's content failed to return expected # of bytes");
+        }
+        if (N_rp->ai_family == AF_INET) {
+          /* and send the buffer's content to the target process.  Note that
+           * this code assumes that the entire buffer can be sent in a single
+           * packet.  If it can not (giant packet), the user may be doing
+           * something wrong.  */
+          if (sendto(N_fd, tempbuf, statbuf.st_size, 0,
+                  (struct sockaddr *) ((N_rp)->ai_addr),
+                  sizeof (struct sockaddr_in)) < 0) {
+            PFATAL("partial or failed UDP write (IPv4)");
+          }
+        } else if (N_rp->ai_family == AF_INET6) {
+          if (sendto(N_fd, tempbuf, statbuf.st_size, 0,
+                  (struct sockaddr *) ((N_rp)->ai_addr),
+                  sizeof (struct sockaddr_in6)) < 0) {
+            PFATAL("partial or failed UDP write (IPv6)");
+          }
+        }
+        /* leave a clean campsite (as we found it) */
+        lseek(fd, 0, SEEK_SET);
+        close(fd);
+      }
+    }
+  } else {
+    /* this should never be executed */
+    FATAL("no address information structures match command line network spec");
+  }
+  
+  return 0;
+}
 
 /* Spin up fork server (instrumented mode only). The idea is explained here:
 
@@ -2032,7 +2565,7 @@
     dup2(dev_null_fd, 1);
     dup2(dev_null_fd, 2);
 
-    if (out_file) {
+    if (out_file || N_valid == 1) { /* no stdin for file or network input */
 
       dup2(dev_null_fd, 0);
 
@@ -2262,6 +2795,12 @@
 
   child_timed_out = 0;
 
+  /* check to ensure that network listener has executed if doing network
+   * fuzzing of a client target (where the target writes to a socket first */
+  if (N_fuzz_client && !N_myaddr_valid) {
+    network_setup_listener();
+  }
+  
   /* After this memset, trace_bits[] are effectively volatile, so we
      must prevent any earlier operations from venturing into that
      territory. */
@@ -2312,7 +2851,7 @@
       dup2(dev_null_fd, 1);
       dup2(dev_null_fd, 2);
 
-      if (out_file) {
+      if (out_file || N_valid == 1) { /* no stdin for file or network input */
 
         dup2(dev_null_fd, 0);
 
@@ -2376,6 +2915,31 @@
 
   }
 
+  /* Write fuzzed data set to target using network if -N option is specified */
+
+  if (N_valid) {
+    if (N_timeout_given) {
+      /* Network output to target process after specified delay, and try
+       * up to three times (hard-coded) */
+      N_it.tv_sec = (N_exec_tmout / 1000);
+      N_it.tv_nsec = (N_exec_tmout % 1000) * 1000000;
+      /* ignore errors & accept possibility that delay can be shorter */
+      {
+       u32 N_tries = 3;
+       nanosleep(&N_it, NULL);
+       /* attempt to send up to 3 times (because of target process startup time) */
+       while (N_tries-- &&
+               ((N_fuzz_client?network_listen():network_send()) == -1));
+      }
+    } else {
+      /* Network output to target process - no delay.  This usual won't work. */
+      if ((N_fuzz_client?network_listen():network_send()) == -1) {
+       FATAL("Network: failed to connect or send; specify a network delay time");
+      }
+    }
+  }
+
+
   /* Configure timeout, as requested by user, then wait for child to terminate. */
 
   it.it_value.tv_sec = (exec_tmout / 1000);
@@ -6974,6 +7538,30 @@
        "Execution control settings:\n\n"
 
        "  -f file       - location read by the fuzzed program (stdin)\n"
+       "  -N URL        - fuzzed program is to read from a network port.\n"
+       "                  The network is specified by URL = type://path:port\n"
+       "                  where type= {udp|tcp}, path={::1|127.0.0.1|localhost},\n"
+       "                  and port is a port number or service name.\n"
+       "                  There are two cases, where the target program to be\n"
+       "                  fuzzed is either a server to afl-fuzz (the default)\n"
+       "                  or a client of afl-fuzz (using the -b option).  If the\n"
+       "                  target is a server, then afl-fuzz sends fuzzed data\n"
+       "                  to the address and port specified in the URL.  If\n"
+       "                  the target is a client, then afl-fuzz listens for\n"
+       "                  data on the specified port and responds by sending\n"
+       "                  fuzzed data to the (typically ephemeral) port used\n"
+       "                  by the target.  Note that the '+' is likely to be\n"
+       "                  necessary after the -t delay option for network\n"
+       "                  fuzzing.\n"
+       "  -D msec       - for network fuzzing only: delay in msec before\n"
+       "                  a network read/write/connection is attempted;\n"
+       "                  Note that 3 attempts are made, with this\n"
+       "                  delay between each (-t is still in effect)\n"
+       "  -b            - specify this option if the fuzzed program is a\n"
+       "                  network client (meaning it writes to the network\n"
+       "                  before reading (a fuzzed input) from the network.\n"
+       "                  The port is the port number to which the network\n"
+       "                  client is expected to write.\n"
        "  -t msec       - timeout for each run (auto-scaled, 50-%u ms)\n"
        "  -m megs       - memory limit for child process (%u MB)\n"
        "  -Q            - use binary-only instrumentation (QEMU mode)\n\n"     
@@ -7521,13 +8109,15 @@
 
 static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {
 
-  char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));
+  char** new_argv = ck_alloc(sizeof(char*) * (argc + 6));
   u8 *tmp, *cp, *rsl, *own_copy;
 
-  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);
+  memcpy(new_argv + 5, argv + 1, sizeof(char*) * argc);
 
-  new_argv[2] = target_path;
-  new_argv[1] = "--";
+  new_argv[4] = target_path;
+  new_argv[3] = "--";
+  new_argv[2] = qemu_lib_path;
+  new_argv[1] = "-L";
 
   /* Now we need to actually find the QEMU binary to put in argv[0]. */
 
@@ -7638,7 +8228,7 @@
   gettimeofday(&tv, &tz);
   srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());
 
-  while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:Q")) > 0)
+  while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:QL:N:D:b")) > 0) {
 
     switch (opt) {
 
@@ -7806,11 +8396,227 @@
 
         break;
 
+      case 'L': /* specify the library path for QEMU mode */
+
+        if (qemu_lib_path) FATAL("Multiple -L options not supported");
+        qemu_lib_path = optarg;
+        break;
+
+      case 'N':
+
+        /* -N{network-path} : inject data to target via network connection
+         * 
+         * The network-path has the form "type://path:port" where
+         * 
+         * type is one of "udp", or "tcp",
+         * path is a host name or IP address (IPv4 or IPv6), and
+         * port is a port number or service name.
+         * 
+         * for the moment, make a copy of the -N option string and
+         * indicate that the -N option has been specified
+         * 
+         */
+
+        if (N_option_specified) FATAL("multiple -N options not allowed");
+        N_slen = strlen(optarg);
+        if (N_slen > 0) {
+          N_option_string = (u8*)ck_alloc(N_slen+1);
+          strcpy(N_option_string,optarg);
+          N_option_specified = 1;
+        } else {
+          FATAL("-N: missing argument");
+        }
+        break;
+
+      case 'D':
+
+        if (N_timeout_given) FATAL("Multiple -D options not supported");
+        if (sscanf(optarg, "%u", &N_exec_tmout) < 1 ||
+                optarg[0] == '-') FATAL("Bad syntax used for -D");
+        N_timeout_given = 1;
+        break;
+
+      case 'b':
+
+        if (N_fuzz_client) FATAL("Multiple -b options not supported");
+        N_fuzz_client = 1;
+        break;
+
       default:
 
         usage(argv[0]);
 
     }
+  }
+
+  /* check for consistent use of network options (-N, -D, and -b) */
+  if (N_fuzz_client && !N_option_specified)
+    FATAL("-b (network client) option requires -N (network) option");
+  if (N_timeout_given && !N_option_specified)
+    FATAL("-D option can not be used without -N option");
+  
+  /* process network option(s), creating and configuring socket */
+  if (N_option_specified) {
+    
+    /* local variables (not needed later):      */
+    struct addrinfo N_hints; /* used for getaddrinfo() call */
+    /* These are all pointers used to process the -N network-path        */
+    u8  *N_found1 = 0,
+        *N_found2 = 0,
+        *N_pchar,
+        *N_type;
+    u8  *N_servicename = 0, /* ptr to start of servicename */
+        *N_hostspec = 0; /* ptr to start of hostname    */
+    
+    /* prepare (zero) addrinfo structure used for hints to getaddrinfo()*/
+    memset(&N_hints, 0, sizeof (struct addrinfo));
+    
+    /* process the -N option string -- two cases depending on N_fuzz_client */
+    if (N_fuzz_client) {
+      /* this is the case where afl-fuzz listens for the target to either
+       * connect and write (TCP) to afl-fuzz's socket or create a socket
+       * and send to (UDP) the afl-fuzz socket. */
+      N_found1 = strpbrk(N_option_string, "://");
+      if (!N_found1) {
+        FATAL("-N: invalid specification");
+      } else {
+        if (*N_found1 != ':')
+          FATAL("-N: first char after type must be ':'");
+        N_type = N_option_string;
+        *N_found1 = 0;
+        N_pchar = N_type;
+        while (*N_pchar != 0) {
+          *N_pchar = tolower(*N_pchar);
+          ++N_pchar;
+        }
+        if (strcmp(N_type, "tcp") == 0) {
+          N_hints.ai_flags = (AI_PASSIVE);
+          N_hints.ai_family = AF_UNSPEC;
+          N_hints.ai_socktype = SOCK_STREAM;
+        } else if (strcmp(N_type, "udp") == 0) {
+          N_hints.ai_flags = (AI_PASSIVE /* | AI_NUMERICSERV */); //COMMENTED OUT
+          N_hints.ai_family = AF_UNSPEC;
+          N_hints.ai_socktype = SOCK_DGRAM;
+        } else {
+          FATAL("-N: invalid type");
+        }
+      }
+
+      if ((N_found1 - N_option_string) >= N_slen)
+        FATAL("-N: incomplete specification");
+
+      /* find the port number */
+      N_found2 = strrchr(N_found1 + 1, ':');
+      if (!N_found2) {
+        FATAL("-N: TCP and UDP operation require a port number");
+      } else {
+        *N_found2 = 0;
+        if (*(N_found2 + 1) == 0) {
+          FATAL("-N: no port number or service name specified");
+        } else {
+          N_servicename = N_found2 + 1;
+        }
+      }
+
+      if ((strncmp(N_found1 + 1, "//", 2)) != 0) {
+        FATAL("-N: invalid network specification - malformed \"://\"");
+      } else {
+        *N_found1 = 0;
+        N_hostspec = N_found1 + 3;
+      }
+      if (!(
+              (strcmp("localhost", N_hostspec) == 0)
+              || (strcmp("::1", N_hostspec) == 0)
+              || (strcmp("127.0.0.1", N_hostspec) == 0)
+              )
+              ) FATAL("-N: only hosts allowed are localhost, ::1, and 127.0.0.1");
+
+      if (strcmp("localhost",N_hostspec) == 0) {
+        N_hints.ai_family = AF_UNSPEC;
+      } else if (strcmp("::1",N_hostspec) == 0) {
+        N_hints.ai_family = AF_INET6;
+      } else {
+        N_hints.ai_family = AF_INET;
+      }
+      if (getaddrinfo(N_hostspec, N_servicename, &N_hints, &N_results) != 0) {
+        FATAL("-N: getaddrinfo() lookup failed");
+      } else {
+        N_valid = 1;
+      }
+    } else {
+      /* This is the case where afl-fuzz either connects to the target
+       * and writes (TCP) or creates a socket and sends to the target (UDP). */
+      N_found1 = strpbrk(N_option_string, "://");
+      if (!N_found1) {
+        FATAL("-N: invalid specification");
+      } else {
+        if (*N_found1 != ':')
+          FATAL("-N: first char after type must be ':'");
+        N_type = N_option_string;
+        *N_found1 = 0;
+        N_pchar = N_type;
+        while (*N_pchar != 0) {
+          *N_pchar = tolower(*N_pchar);
+          ++N_pchar;
+        }
+        if (strcmp(N_type, "tcp") == 0) {
+          N_hints.ai_flags = (AI_V4MAPPED | AI_ADDRCONFIG);
+          N_hints.ai_family = AF_UNSPEC;
+          N_hints.ai_socktype = SOCK_STREAM;
+        } else if (strcmp(N_type, "udp") == 0) {
+          N_hints.ai_flags = (AI_V4MAPPED | AI_ADDRCONFIG);
+          N_hints.ai_family = AF_UNSPEC;
+          N_hints.ai_socktype = SOCK_DGRAM;
+        } else {
+          FATAL("-N: invalid type");
+        }
+      }
+
+      if ((N_found1 - N_option_string) >= N_slen)
+        FATAL("-N: incomplete specification");
+
+      if (N_hints.ai_family == AF_UNSPEC) { //redundant - for future use
+        /* TCP and UDP operation require a port number */
+        N_found2 = strrchr(N_found1 + 1, ':');
+        if (!N_found2) {
+          FATAL("-N: TCP and UDP operation require a port number");
+        } else {
+          *N_found2 = 0;
+          if (*(N_found2 + 1) == 0) {
+            FATAL("-N: no port number or service name specified");
+          } else {
+            N_servicename = N_found2 + 1;
+          }
+        }
+      }
+
+      if ((strncmp(N_found1 + 1, "//", 2)) != 0) {
+        FATAL("-N: invalid network specification - malformed \"://\"");
+      } else {
+        *N_found1 = 0;
+        N_hostspec = N_found1 + 3;
+      }
+      if (!(
+              (strcmp("localhost", N_hostspec) == 0)
+              || (strcmp("::1", N_hostspec) == 0)
+              || (strcmp("127.0.0.1", N_hostspec) == 0)
+              )
+              ) FATAL("-N: only hosts allowed are localhost, ::1, and 127.0.0.1");
+
+      if (N_hints.ai_family == AF_UNSPEC) {
+        if (getaddrinfo(N_hostspec, N_servicename, &N_hints, &N_results) != 0) {
+          FATAL(  "-N: getaddrinfo() lookup failed");
+        } else {
+          N_valid = 1;
+        }
+      }
+    }
+  }
+
+  //  exit(0); //TESTING
+    
+
+  if (!qemu_mode && qemu_lib_path) FATAL("-L must be used with -Q");
 
   if (optind == argc || !in_dir || !out_dir) usage(argv[0]);
 
diff -aur afl-2.39b.orig/docs/README afl-2.39b/docs/README
--- afl-2.39b.orig/docs/README	2017-01-14 05:41:35.000000000 +0800
+++ afl-2.39b/docs/README	2017-04-19 23:44:34.690000002 +0800
@@ -180,6 +180,18 @@
 You can also use the -f option to have the mutated data written to a specific
 file. This is useful if the program expects a particular file extension or so.
 
+For programs that accept input via a network, use:
+
+$ ./afl-fuzz -i testcase_dir -o findings_dir [-D delay_before_write] \
+             [-t timeout_delay] [-b] -N network_specification /path/to/program \
+	     [...params...]
+
+where -b is specified only if the target program acts as a client to a network
+server (sends data to the server before receiving input in return).  Otherwise,
+afl-fuzz assumes the target program acts as a server or daemon and expects to
+receive data from network clients and respond.  The network_specification
+and the delay parameters are discussed below in (12).
+
 Non-instrumented binaries can be fuzzed in the QEMU mode (add -Q in the command
 line) or in a traditional, blind-fuzzer mode (specify -n).
 
@@ -262,6 +274,9 @@
 fuzzers, to symbolic or concolic execution engines, and so forth; again, see the
 last section of parallel_fuzzing.txt for tips.
 
+Note the limitations to multi-core execution for fuzzing network services under
+(13).
+
 9) Fuzzer dictionaries
 ----------------------
 
@@ -396,7 +411,115 @@
 
     $ iostat -d 3 -x -k [...optional disk ID...]
 
-13) Known limitations & areas for improvement
+13) Fuzzing network services
+----------------------------
+
+Both client and server (daemon) programs that communicate using an 
+IP network (IPv4 or IPv6) can be fuzzed using the command line
+
+$ ./afl-fuzz -i testcase_dir -o findings_dir [-D delay_before_write] \
+             [-t timeout_delay] [-b] -N network_specification /path/to/program \
+             [...params...]
+
+where the network_specification has a form similar to a URL:
+
+    [tcp|udp]://hostspec:port
+
+Afl-fuzz has two network fuzzing modes, where it acts as a client to a
+network server that expects input via a socket (no -b option), and where it
+acts as a server to a network client that sends data to afl-fuzz before
+receiving input (using the -b option).  In the first case, afl-fuzz sends data
+to the port specified by the URL.  In the second case, afl-fuzz receives data
+on that port and sends a (fuzzed) response to the port the target (client) used
+to send its data.
+
+Note that when afl-fuzz acts as a server (the -b option), there is no control
+over how the target client manages its use of sockets - and in particular, a
+client that uses ephemeral sockets (the usual case) will rapidly consume the
+network stack's pool of available sockets.  Some operating systems are able to
+reclaim used ephemeral sockets to keep the pool from being exhausted; others
+may experience difficulties.
+
+While the -D and -t command line arguments are optional, they are almost
+always necessary when fuzzing a program using network protocols, as
+described below.
+
+Case is irrelevant in the network specification.  For programs that
+use a stream (connection-based) protocol, use TCP, and for programs
+that use a datagram (connectionless) protocol, use UDP.  The hostspec
+must be one of ::1 (forcing IPv6 networking), 127.0.0.1 (forcing IPv4
+networking), and localhost (which is typically configured as IPv4 but
+may suppport IPv6 on some systems).  Only loopback networking (local
+to the host) is supported.  The port must be either a port number in
+the range 1..65535 or a service name known to the system being used.
+You can test programs that use privileged ports, but you then have to
+provide afl-fuzz with those additional privileges (e.g., root).  It is
+usually better to reconfigure the program being tested so that it will
+use a non-privileged port during fuzzing.
+
+Programs that implement network services, also called daemons, are
+typically transaction-based: They wait for a request and send a
+response, and some expect a sequence of request/response transactions.
+Afl-fuzz implements fuzzing only for the first write to the target
+program and ignores all responses from the target.  Most network
+services expect to run as background processes and process requests
+from many processes -- they do not normally exit.  A timeout delay is
+required in order to terminate these processes, and the default
+timeout delay used in afl-fuzz is usually too long.  The user needs to
+experimentally determine a timeout delay (in milliseconds) that
+produces a sufficiently low percentage of hangs (exits forced by
+expiration of the delay) while allowing the input to the target from
+afl-fuzz to be completely processed.  (Note that afl-fuzz will usually
+count these hangs as a single unique hang.) Since a network service
+does not normally exit, the initial timing performed by afl-fuzz will
+fail unless a '+' character is appended to the timeout_delay
+parameter, indicating that afl-fuzz is to ignore these timeouts.
+
+Network services programs also require some time to perform start-up
+processing, create and bind a socket to an address and port, and begin
+listening for traffic on that socket.  Connection requests (TCP) and
+sends (UDP) generated by afl-fuzz will fail if made before the network
+service is ready.  Afl-fuzz implements a delay and retry procedure to
+avoid this problem, where the delay is specified by the
+delay_before_write parameter (in milliseconds).  The first connection
+attempt (for TCP) or write (for UDP) is not made until after this
+delay, and the delay also specifies the wait time before each
+subsequent attempt.  Afl-fuzz will attempt to connect or send to the
+same each target process a maximum of three times.
+
+The delay_before_write parameter, in particular, and to a lesser
+extent the timeout_delay parameter limit the maximum achievable rate
+of target program executions and therefore need to be small. A rule of
+thumb is the timeout_delay value should be slightly longer than three
+times the delay_before_write value, and the delay_before_write value
+should be as small as possible while consistent with an acceptable
+fraction of target process executions that time out (for example,
+around 0.1%).
+
+Network client program have similar characteristics that require the use of
+the delay parameter, but they write to their expected server (afl-fuzz in this
+case) before reading from their network socket.  This makes coordination between
+afl-fuzz and (client) target somewhat more challenging.  While the delay and
+timeout parameters can usually be adjusted to obtain execution rates similar
+to those for server programs, when afl-fuzz exits (due to a ^C interrupt) it
+may hang.  In this case, use (on UNIX or Linux) the ps command to find the
+process id (PID) of the afl-fuzz process, and use the kill command to terminate
+it (typically, "kill -9 PID").  This will also terminate (or scavenge) the
+network client program's process, which may be in a zombie state that can not
+otherwise be removed (without rebooting the system).
+
+A note concerning network fuzzing on multi-core systems:
+
+It is not possible to run two processes under a single operating
+system kernel that bind to (listen to) the same port on the same
+address. Thus, either a special wrapper (such as could be implemented
+using LD_PRELOAD) can be used to remap each target's port to a
+different value, or only one target process can be executed per kernel
+(not per core). Parallel fuzzing of network services can be done using
+several independent hosts (a cluster), or by reconfiguring the code
+running on each core to use a different port.
+
+14) Known limitations & areas for improvement
 ---------------------------------------------
 
 Here are some of the most important caveats for AFL:
@@ -420,11 +543,15 @@
     isn't due to any specific fault of afl-fuzz; see notes_for_asan.txt for
     tips.
 
-  - There is no direct support for fuzzing network services, background
-    daemons, or interactive apps that require UI interaction to work. You may
-    need to make simple code changes to make them behave in a more traditional
-    way. Preeny may offer a relatively simple option, too - see:
-    https://github.com/zardus/preeny
+  - The supplied method for fuzzing network services or background daemons
+    is limited to fuzzing the first packet received by the service or daemon.
+    Since many of these processes are transactional, it may be desirable to
+    provide a deterministic sequence of transactions with the target,
+    followed by fuzzing. This is not supported and would be a nice topic
+    for future work. Interactive apps that require UI interaction to work
+    are also not supported. You may need to make simple code changes to
+    make them behave in a more traditional way. Preeny may offer a relatively
+    simple option, too - see: https://github.com/zardus/preeny
 
     Some useful tips for modifying network-based services can be also found at:
     https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop
@@ -435,9 +562,13 @@
   - Occasionally, sentient machines rise against their creators. If this
     happens to you, please consult http://lcamtuf.coredump.cx/prep/.
 
+  - Only afl-fuzz implements network fuzzing capabilities at this time.  In
+    particular, afl-cmin (a script), afl-tmin, and afl-showmap, all of which
+    execute the target program, do not.
+
 Beyond this, see INSTALL for platform-specific tips.
 
-14) Special thanks
+15) Special thanks
 ------------------
 
 Many of the improvements to afl-fuzz wouldn't be possible without feedback,
@@ -481,10 +612,11 @@
   Joshua J. Drake                       Toby Hutton
   Rene Freingruber                      Sergey Davidoff
   Sami Liedes                           Craig Young
+  Doug Birdwell
 
 Thank you!
 
-15) Contact
+16) Contact
 -----------
 
 Questions? Concerns? Bug reports? The author can be usually reached at
diff -aur afl-2.39b.orig/Makefile afl-2.39b/Makefile
--- afl-2.39b.orig/Makefile	2017-01-15 09:50:54.000000000 +0800
+++ afl-2.39b/Makefile	2017-04-19 11:16:14.309999987 +0800
@@ -28,7 +28,7 @@
 SH_PROGS    = afl-plot afl-cmin afl-whatsup
 
 CFLAGS     ?= -O3 -funroll-loops
-CFLAGS     += -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign \
+CFLAGS     += -Wall -D_FORTIFY_SOURCE=2 -O3 -Wno-pointer-sign \
 	      -DAFL_PATH=\"$(HELPER_PATH)\" -DDOC_PATH=\"$(DOC_PATH)\" \
 	      -DBIN_PATH=\"$(BIN_PATH)\"
 
@@ -122,7 +122,7 @@
 	rm -f $${DESTDIR}$(BIN_PATH)/afl-plot.sh
 	install -m 755 $(PROGS) $(SH_PROGS) $${DESTDIR}$(BIN_PATH)
 	rm -f $${DESTDIR}$(BIN_PATH)/afl-as
-	if [ -f afl-qemu-trace ]; then install -m 755 afl-qemu-trace $${DESTDIR}$(BIN_PATH); fi
+	if [ -f afl-qemu-trace ]; then install -m 755 afl-qemu-trace $${DESTDIR}$(BIN_PATH); cp -r afl-qemu-trace-* $${DESTDIR}$(BIN_PATH); fi
 ifndef AFL_TRACE_PC
 	if [ -f afl-clang-fast -a -f afl-llvm-pass.so -a -f afl-llvm-rt.o ]; then set -e; install -m 755 afl-clang-fast $${DESTDIR}$(BIN_PATH); ln -sf afl-clang-fast $${DESTDIR}$(BIN_PATH)/afl-clang-fast++; install -m 755 afl-llvm-pass.so afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH); fi
 else
diff -aur afl-2.39b.orig/qemu_mode/build_qemu_support.sh afl-2.39b/qemu_mode/build_qemu_support.sh
--- afl-2.39b.orig/qemu_mode/build_qemu_support.sh	2016-03-08 15:10:20.000000000 +0800
+++ afl-2.39b/qemu_mode/build_qemu_support.sh	2017-04-19 11:16:14.309999987 +0800
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # american fuzzy lop - QEMU build script
 # --------------------------------------
@@ -22,13 +22,8 @@
 # will be written to ../afl-qemu-trace.
 #
 
-QEMU_URL="http://wiki.qemu-project.org/download/qemu-2.3.0.tar.bz2"
-QEMU_SHA384="7a0f0c900f7e2048463cc32ff3e904965ab466c8428847400a0f2dcfe458108a68012c4fddb2a7e7c822b4fd1a49639b"
-
-echo "================================================="
-echo "AFL binary-only instrumentation QEMU build script"
-echo "================================================="
-echo
+QEMU_URL="http://download.qemu-project.org/qemu-2.8.0.tar.xz"
+QEMU_SHA384="c305ec10747cb2a67f2435f20f37cb78ed59d8ab4e9d1c6e9b17fe8111fe462f8053b34f317af8526a8a4f4eda7b6481"
 
 echo "[*] Performing basic sanity checks..."
 
@@ -89,7 +84,7 @@
 
 if [ ! "$CKSUM" = "$QEMU_SHA384" ]; then
 
-  echo "[*] Downloading QEMU 2.3.0 from the web..."
+  echo "[*] Downloading QEMU 2.8.0 from the web..."
   rm -f "$ARCHIVE"
   wget -O "$ARCHIVE" -- "$QEMU_URL" || exit 1
 
@@ -110,36 +105,31 @@
 
 echo "[*] Uncompressing archive (this will take a while)..."
 
-rm -rf "qemu-2.3.0" || exit 1
+rm -rf "qemu-2.8.0" || exit 1
 tar xf "$ARCHIVE" || exit 1
 
 echo "[+] Unpacking successful."
 
 echo "[*] Applying patches..."
 
-patch -p0 <patches/elfload.diff || exit 1
-patch -p0 <patches/cpu-exec.diff || exit 1
-patch -p0 <patches/translate-all.diff || exit 1
-patch -p0 <patches/syscall.diff || exit 1
+patch -p0 <patches/qemu-2.8.0.diff || exit 1
 
 echo "[+] Patching done."
 
-ORIG_CPU_TARGET="$CPU_TARGET"
-
-test "$CPU_TARGET" = "" && CPU_TARGET="`uname -m`"
-test "$CPU_TARGET" = "i686" && CPU_TARGET="i386"
+echo "[*] Configuring QEMU..."
 
-echo "[*] Configuring QEMU for $CPU_TARGET..."
+cd qemu-2.8.0 || exit 1
 
-cd qemu-2.3.0 || exit 1
+CC=gcc
+CXX=g++
 
-CFLAGS="-O3" ./configure --disable-system --enable-linux-user \
-  --enable-guest-base --disable-gtk --disable-sdl --disable-vnc \
-  --target-list="${CPU_TARGET}-linux-user" || exit 1
+CFLAGS="-O3" ./configure --python=/usr/bin/python2 --disable-system \
+  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \
+  --target-list="aarch64-linux-user armeb-linux-user arm-linux-user i386-linux-user mips64el-linux-user mips64-linux-user mipsel-linux-user mips-linux-user mipsn32el-linux-user mipsn32-linux-user ppc64abi32-linux-user ppc64le-linux-user ppc64-linux-user ppc-linux-user x86_64-linux-user" || exit 1
 
 echo "[+] Configuration complete."
 
-echo "[*] Attempting to build QEMU (fingers crossed!)..."
+echo "[*] Attempting to build QEMU..."
 
 make || exit 1
 
@@ -147,50 +137,48 @@
 
 echo "[*] Copying binary..."
 
-cp -f "${CPU_TARGET}-linux-user/qemu-${CPU_TARGET}" "../../afl-qemu-trace" || exit 1
+for CPU_TARGET in "aarch64" "armeb" "arm" "i386" "mips64el" "mips64" "mipsel" "mips" "mipsn32el" "mipsn32" "ppc64abi32" "ppc64le" "ppc64" "ppc" "x86_64"
+do
+  mkdir "../../afl-qemu-trace-${CPU_TARGET}"
+  cp -f "${CPU_TARGET}-linux-user/qemu-${CPU_TARGET}" "../../afl-qemu-trace-${CPU_TARGET}/afl-qemu-trace" || exit 1
+  strip -s "../../afl-qemu-trace-${CPU_TARGET}/afl-qemu-trace"
+done
+
+cp -f "../../afl-qemu-trace-$(uname -m)/afl-qemu-trace" "../../afl-qemu-trace" || exit 1
 
 cd ..
-ls -l ../afl-qemu-trace || exit 1
+ls -l ../afl-qemu-trace* || exit 1
 
 echo "[+] Successfully created '../afl-qemu-trace'."
 
-if [ "$ORIG_CPU_TARGET" = "" ]; then
-
-  echo "[*] Testing the build..."
-
-  cd ..
-
-  make >/dev/null || exit 1
-
-  gcc test-instr.c -o test-instr || exit 1
+echo "[*] Testing the build..."
 
-  unset AFL_INST_RATIO
+cd ..
 
-  echo 0 | ./afl-showmap -m none -Q -q -o .test-instr0 ./test-instr || exit 1
-  echo 1 | ./afl-showmap -m none -Q -q -o .test-instr1 ./test-instr || exit 1
+make >/dev/null || exit 1
 
-  rm -f test-instr
+gcc test-instr.c -o test-instr || exit 1
 
-  cmp -s .test-instr0 .test-instr1
-  DR="$?"
+unset AFL_INST_RATIO
 
-  rm -f .test-instr0 .test-instr1
+echo 0 | ./afl-showmap -m none -Q -q -o .test-instr0 ./test-instr || exit 1
+echo 1 | ./afl-showmap -m none -Q -q -o .test-instr1 ./test-instr || exit 1
 
-  if [ "$DR" = "0" ]; then
+rm -f test-instr
 
-    echo "[-] Error: afl-qemu-trace instrumentation doesn't seem to work!"
-    exit 1
+cmp -s .test-instr0 .test-instr1
+DR="$?"
 
-  fi
+rm -f .test-instr0 .test-instr1
 
-  echo "[+] Instrumentation tests passed. "
-  echo "[+] All set, you can now use the -Q mode in afl-fuzz!"
+if [ "$DR" = "0" ]; then
 
-else
-
-  echo "[!] Note: can't test instrumentation when CPU_TARGET set."
-  echo "[+] All set, you can now (hopefully) use the -Q mode in afl-fuzz!"
+  echo "[-] Error: afl-qemu-trace instrumentation doesn't seem to work!"
+  exit 1
 
 fi
 
+echo "[+] Instrumentation tests passed. "
+echo "[+] All set, you can now use the -Q mode in afl-fuzz!"
+
 exit 0
diff -aur afl-2.39b.orig/qemu_mode/patches/afl-qemu-cpu-inl.h afl-2.39b/qemu_mode/patches/afl-qemu-cpu-inl.h
--- afl-2.39b.orig/qemu_mode/patches/afl-qemu-cpu-inl.h	2016-02-21 06:22:07.000000000 +0800
+++ afl-2.39b/qemu_mode/patches/afl-qemu-cpu-inl.h	2017-04-19 11:16:14.309999987 +0800
@@ -49,7 +49,7 @@
 #define AFL_QEMU_CPU_SNIPPET2 do { \
     if(tb->pc == afl_entry_point) { \
       afl_setup(); \
-      afl_forkserver(env); \
+      afl_forkserver(cpu->env_ptr); \
     } \
     afl_maybe_log(tb->pc); \
   } while (0)
@@ -81,14 +81,16 @@
 /* Function declarations. */
 
 static void afl_setup(void);
-static void afl_forkserver(CPUArchState*);
+static void afl_forkserver(CPUState*);
 static inline void afl_maybe_log(abi_ulong);
 
-static void afl_wait_tsl(CPUArchState*, int);
+static void afl_wait_tsl(CPUState*, int);
 static void afl_request_tsl(target_ulong, target_ulong, uint64_t);
 
-static TranslationBlock *tb_find_slow(CPUArchState*, target_ulong,
-                                      target_ulong, uint64_t);
+static TranslationBlock *tb_htable_lookup(CPUState *cpu,
+                                          target_ulong pc,
+                                          target_ulong cs_base,
+                                          uint32_t flags);
 
 
 /* Data structure passed around by the translate handlers: */
@@ -154,7 +156,7 @@
 
 /* Fork server logic, invoked once we hit _start. */
 
-static void afl_forkserver(CPUArchState *env) {
+static void afl_forkserver(CPUState *env) {
 
   static unsigned char tmp[4];
 
@@ -273,7 +275,7 @@
 /* This is the other side of the same channel. Since timeouts are handled by
    afl-fuzz simply killing the child, we can just wait until the pipe breaks. */
 
-static void afl_wait_tsl(CPUArchState *env, int fd) {
+static void afl_wait_tsl(CPUState *env, int fd) {
 
   struct afl_tsl t;
 
@@ -284,7 +286,7 @@
     if (read(fd, &t, sizeof(struct afl_tsl)) != sizeof(struct afl_tsl))
       break;
 
-    tb_find_slow(env, t.pc, t.cs_base, t.flags);
+    tb_htable_lookup(env, t.pc, t.cs_base, t.flags);
 
   }
 
diff -aur afl-2.39b.orig/types.h afl-2.39b/types.h
--- afl-2.39b.orig/types.h	2016-08-03 02:35:04.000000000 +0800
+++ afl-2.39b/types.h	2017-04-19 11:16:14.309999987 +0800
@@ -76,7 +76,9 @@
 #define MEM_BARRIER() \
   asm volatile("" ::: "memory")
 
+#ifndef likely
 #define likely(_x)   __builtin_expect(!!(_x), 1)
 #define unlikely(_x)  __builtin_expect(!!(_x), 0)
+#endif
 
 #endif /* ! _HAVE_TYPES_H */
